using FxKit.CompilerServices.Utilities;

namespace FxKit.CompilerServices.CodeGenerators.Unions;

/// <summary>
///     All the ugly syntax building stuff for the union generator.
/// </summary>
internal static class UnionSyntaxBuilder
{
    /// <summary>
    ///     Generates the union members source.
    /// </summary>
    /// <param name="union"></param>
    /// <returns></returns>
    public static string GenerateUnionMembers(UnionGeneration union)
    {
        using var sb = new IndentedTextWriter();
        sb.WriteLine(SourceGenerationHelper.AutoGeneratedHeader);
        sb.WriteLine(SourceGenerationHelper.NullableEnabledDirective);

        // Add using statements.
        sb.WriteLine("using System;");                          // Needed for Func
        sb.WriteLine("using System.Diagnostics;");              // Needed for [DebuggerHidden]
        sb.WriteLine("using System.Diagnostics.CodeAnalysis;"); // Needed for [ExcludeFromCodeCoverage]
        sb.WriteLine("using System.Runtime.CompilerServices;"); // Needed for [MethodImpl]

        // Add namespace.
        sb.WriteLine();
        sb.WriteLine($"namespace {union.UnionNamespace};\n");

        // Write the type hierarchy.
        using (TypeHierarchyWriter.WriteTypeHierarchy(sb, union.AncestorTypeHierarchy))
        {
            // Add the outer record.
            sb.Write($"{union.Accessibility} abstract partial record {union.UnionNameWithSignature}\n");

            // Print the Union members.
            using (sb.WriteBlock())
            {
                foreach (var constructor in union.Members)
                {
                    PrintUnionConstructor(sb, union, constructor);
                    sb.WriteLine();
                }

                // Print the Match method.
                PrintUnionMatchMethod(sb, union);
            }
        }


        return sb.ToString();
    }

    /// <summary>
    ///     Prints the individual union constructor-related code.
    /// </summary>
    /// <param name="sb"></param>
    /// <param name="union"></param>
    /// <param name="member"></param>
    private static void PrintUnionConstructor(
        IndentedTextWriter sb,
        UnionGeneration union,
        UnionMember member)
    {
        sb.WriteLine(
            $"public sealed partial record {member.MemberNameWithSignature} : {union.UnionNameWithSignature}");
        using (sb.WriteBlock())
        {
            PrintUnionConstructorOf(sb, union, member);
            sb.WriteLine();
            sb.WriteLine();
            PrintUnionConstructorLambda(sb, union, member);
            sb.WriteLine();
        }
    }

    /// <summary>
    ///     Prints the .Of static method.
    /// </summary>
    /// <param name="sb"></param>
    /// <param name="union"></param>
    /// <param name="member"></param>
    private static void PrintUnionConstructorOf(
        IndentedTextWriter sb,
        UnionGeneration union,
        UnionMember member)
    {
        sb.Write(
            $"""
             /// <summary>
             ///     The same as "new {member.MemberName}" but the return type is that of the base type.
             /// </summary>
             [MethodImpl(MethodImplOptions.AggressiveInlining)]
             [ExcludeFromCodeCoverage]
             [DebuggerHidden]
             public static {union.UnionNameWithSignature} Of(
             """,
            isMultiline: true);

        sb.IncreaseIndent();
        for (var i = 0; i < member.Parameters.Length; i++)
        {
            sb.WriteLine();
            var param = member.Parameters[i];
            sb.Write($"{param.FullyQualifiedTypeName} {param.Identifier}");
            sb.WriteIf(i < member.Parameters.Length - 1, ",");
        }

        sb.DecreaseIndent();
        sb.WriteLine(") =>");
        sb.IncreaseIndent();
        sb.Write($"new {member.MemberNameWithSignature}(");
        sb.IncreaseIndent();
        sb.WriteParameterNames(member.Parameters, newlineSeparated: true);
        sb.DecreaseIndent();
        sb.DecreaseIndent();
        sb.Write(");");
    }

    /// <summary>
    ///     Prints the λ func.
    /// </summary>
    /// <param name="sb"></param>
    /// <param name="union"></param>
    /// <param name="member"></param>
    private static void PrintUnionConstructorLambda(
        IndentedTextWriter sb,
        UnionGeneration union,
        UnionMember member)
    {
        sb.Write(
            content: """
                     /// <summary>
                     ///     A Func variant for 'Of'
                     /// </summary>
                     public static readonly Func<
                     """,
            isMultiline: true);

        sb.WriteParameterTypes(member.Parameters);

        // If we have printed a type name for the parameters, then we need to
        // add another comma since it would currently have written only "Func<TypeName".
        if (member.Parameters.Length > 0)
        {
            sb.Write(", ");
        }

        // Alias the lambda to `Of`.
        sb.Write($"{union.UnionNameWithSignature}> λ = Of;");
    }

    /// <summary>
    ///     Prints a Match method that takes in Func.
    /// </summary>
    /// <param name="sb"></param>
    /// <param name="union"></param>
    private static void PrintUnionMatchMethod(IndentedTextWriter sb, UnionGeneration union)
    {
        sb.Write(
            content: """
                     /// <summary>
                     ///     Performs an exhaustive match on the union constituents.
                     /// </summary>
                     public TResult Match<TResult>(
                     """,
            isMultiline: true);

        // Print the parameter names, they will be the names of the constituents.
        var needsComma = false;
        sb.IncreaseIndent();
        foreach (var constructor in union.Members)
        {
            sb.WriteIf(needsComma, ",");

            sb.WriteLine();

            sb.Write($"Func<{constructor.MemberNameWithSignature}, TResult> {constructor.MemberName}");
            needsComma = true;
        }

        // Print the switch expression.
        sb.WriteLine(") => this switch");
        sb.DecreaseIndent();
        sb.WriteLine("{");
        sb.IncreaseIndent();

        // Print the switch arms per union constituent.
        foreach (var constructor in union.Members)
        {
            sb.WriteLine(
                $"{union.UnionNameWithSignature}.{constructor.MemberNameWithSignature} x => {constructor.MemberName}(x),");
        }

        // Default arm
        sb.WriteLine(
            $$"""
              _ => throw new ArgumentOutOfRangeException(message: $"The type '{this.GetType()}' is not a known variant of {{union.UnionName}}", innerException: null)
              """);
        sb.DecreaseIndent();
        sb.WriteLine("};");
    }
}
